<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="de" xml:lang="de">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <style type="text/css">
  body {
      font-family: sans-serif;
      margin: 0 auto;
      padding: 1em;
      max-width: 40em;
      font-size: 16px;
      line-height: 1.5;
  }
  
  p {
      text-align: justify;
      hyphens: auto;
  }
  
  li {
      hyphens: auto;
  }
  
  pre {
      font-size: 90%;
  }
  
  h1.title {
      font-size: 200%;
      text-align: center;
  }
  
  h1.subtitle {
      font-size: 130%;
      text-align: center;
  }
  
  h2.author {
      font-size: 100%;
      text-align: center;
      font-weight: normal;
  }
  
  h3.date {
      font-size: 100%;
      text-align: center;
      font-weight: normal;
  }
  
  h1 {
      font-size: 130%;
  }
  
  sup a {
      text-decoration: none;
  }
  </style>
</head>
<body>
<div id="header">
<h1 class="title">Linux und Textdateien</h1>
<h1 class="subtitle">Effizient arbeiten mit einfachen Mitteln</h1>
<h2 class="author">Patrick Bucher</h2>
<h3 class="date">29.04.2017</h3>
</div>
<p><strong>Windows- und Mac-User schreiben Texte meistens mit <em>Word</em>. Mit <em>LibreOffice Writer</em> gibt es eine kostenlose Alternative zu <em>Word</em>, die auch unter Linux läuft. Hartgesottene Linux-User verwenden aber lieber einen Texteditor zum Schreiben ihrer Texte. Warum ist das so?</strong></p>
<p>Microsofts kostenpflichtige Textverarbeitung <em>Word</em> aus der <em>Office</em>-Suite verwendet als Dateiformat <a href="http://officeopenxml.com/"><em>Office Open XML</em></a> (OOXML). Die Open-Source-Textverarbeitung <a href="https://www.libreoffice.org/discover/writer/"><em>LibreOffice Writer</em></a> verwendet hingegen <a href="http://opendocumentformat.org/"><em>OpenDocument Text</em></a> (ODT) als Dateiformat. Beide Programme (<em>Word</em> und <em>Writer</em>) unterstützen beide Formate (OOXML und ODT).</p>
<p>Texteditoren verwenden als Dateiformat einfache Textdateien.</p>
<h1 id="unterschiede-zwischen-textdateien-und-ooxmlodt">Unterschiede zwischen Textdateien und OOXML/ODT</h1>
<p>OOXML und ODT speichern Texte in einer komprimierten XML-Struktur ab. Einfache Textdateien haben keine solche Struktur, sondern bestehen nur aus einer Reihe von Zeichen. Dadurch ergeben sich einige Unterschiede in der Handhabung von OOXML/ODT-Dateien einerseits und Textdateien andererseits:</p>
<ol style="list-style-type: decimal">
<li>OOXML/ODT-Dateien lassen sich nur mit <em>Word</em> und <em>Writer</em> zuverlässig bearbeiten. Textdateien lassen sich mit einem beliebigen Texteditor bearbeiten.</li>
<li>OOXML/ODT-Dateien enthalten viele Zusatzinformationen für Formatierung, Struktur und zusätzliche Einstellungen. Textdateien haben diesen <em>Overhead</em> nicht, da sie nur die eigentlichen Nutzdaten enthalten.</li>
<li>OOXML/ODT-Dateien können nur so lange gelesen werden, wie die entsprechenden Programme dazu verfügbar sind. Textdateien, die nur aus einer Reihe von Zeichen bestehen, können immer gelesen werden.</li>
<li>OOXML/ODT-Dateien lassen sich nur im «WYSIWYG»-Modus («what you see is what you get») bearbeiten. Textdateien lassen sich auch als <em>Textstrom</em> bearbeiten.</li>
</ol>
<p>Die ersten drei Punkte sprechen klar <em>für</em> den Einsatz von Textdateien. Doch welche Vorteile bietet ein <em>Textstrom</em>?</p>
<h1 id="beispiel-wörter-in-artikeln-zählen">Beispiel: Wörter in Artikeln zählen</h1>
<p>Angenommen wir haben eine Reihe von Artikeln; einmal im ODT-Format (Endung <code>.odt</code>) und einmal im Textformat (Endung <code>.txt</code>). Nun wollen wir herausfinden, welcher Artikel am meisten Wörter enthält. Mit unseren ODT-Dateien machen wir folgendes:</p>
<ol style="list-style-type: decimal">
<li>Wir öffnen den ersten Artikel mit <em>Writer</em>.</li>
<li>Wir gehen auf das Menü <em>Tools</em> und wählen den Eintrag <em>Word Count</em>.</li>
<li>Wir notieren uns den Dateinamen und die Anzahl Wörter.</li>
<li>Wir wiederholen den Vorgang für den nächsten Artikel.</li>
</ol>
<p>Dieses Vorgehen ist sehr aufwändig. Zudem muss der Vorgang später wiederholt werden, wenn die Artikel in der Zwischenzeit verändert worden sind.</p>
<h1 id="der-wc-befehl">Der <code>wc</code>-Befehl</h1>
<p>Mit Textdateien sieht das Vorgehen anders aus. Wir öffnen ein <em>Terminal</em> und verwenden den <a href="http://pubs.opengroup.org/onlinepubs/009604499/utilities/wc.html"><code>wc</code>-Befehl</a>:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="fu">wc</span> -w *.txt</code></pre></div>
<ul>
<li><code>wc</code> steht für «word count» und zählt die Wörter in einer Datei.</li>
<li>Standardmässig gibt <code>wc</code> die Anzahl Zeilen, Wörter und Zeichen einer Datei aus. Mit dem Parameter <code>-w</code> (für «words») erhalten wir nur die Anzahl Wörter.</li>
<li>Mit <code>*.txt</code> übergeben wir dem Programm sämtliche Textdateien im Arbeitsverzeichnis.</li>
</ul>
<p>Dadurch erhalten wir die folgende Ausgabe:</p>
<pre><code>1739 berlinreise.txt
2220 eigenes-bier-brauen.txt
 893 im-stau.txt
1231 neues-aquarium.txt</code></pre>
<h1 id="die-ausgabe-an-sort-weiterleiten">Die Ausgabe an <code>sort</code> weiterleiten</h1>
<p>Wir sehen die Anzahl Wörter in der ersten Spalte, doch die Zeilen sind nicht richtig, d.h. nach der Anzahl der Wörter sortiert. Über das Muster <code>*.txt</code> erhält <code>wc</code> die Dateien in alphabetischer Reihenfolge – und gibt sie auch in alphabetischer Reihenfolge wieder aus. Darum verwenden wir zusätzlich den <a href="http://pubs.opengroup.org/onlinepubs/9699919799/utilities/sort.html"><code>sort</code>-Befehl</a>.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="fu">wc</span> -w *.txt <span class="kw">|</span> <span class="fu">sort</span> -n -r</code></pre></div>
<ul>
<li>Zwischen den Befehlen steht das Zeichen <code>|</code>. Das ist eine sogenannte <em>Pipe</em>, zu Deutsch etwa «Röhre». Eine Pipe nimmt die Ausgabe eines Programmes entgegen und leitet sie als Eingabe zum nächsten Programm weiter. <strong>Der Text «fliesst» als <em>Textstrom</em> durch die Röhre.</strong> Der Vorteil eines Textstroms ist, dass sich damit Befehle kombinieren lassen.</li>
<li>Es folgt der <code>sort</code>-Aufruf, wodurch Textzeilen in alphabetisch aufsteigender Reihenfolge sortiert werden.</li>
<li>Da wir keine alphabetische, sondern eine numerische Sortierung brauchen («100» wäre alphabetisch sortiert kleiner als «9»), geben wir den Parameter <code>-n</code> (für «numeric») an.</li>
<li>Zudem soll die Reihenfolge nicht aufsteigend (die kleinste Zahl zuerst) sondern absteigend (die grösste Zahl zuerst) sein, was wir mit dem Parameter <code>-r</code> (für «reverse») erreichen.</li>
</ul>
<p>Die Ausgabe sieht nun so aus:</p>
<pre><code>2220 eigenes-bier-brauen.txt
1739 berlinreise.txt
1231 neues-aquarium.txt
 893 im-stau.txt</code></pre>
<p>Der Artikel mit den meisten Wörtern ist <code>eigenes-bier-brauen.txt</code>. Für vier Dateien mag das nicht besonders beeindruckend sein. Hätten wir tausende von Dateien, müssten wir zwar die Ausgabe kürzen, ansonsten wäre aber das Vorgehen genau gleich. Doch die Zeitersparnis gegenüber dem manuellen Vorgehen mit ODT-Dateien ist gewaltig. <strong>Die Lösung mit den Textdateien <em>skaliert</em> wesentlich besser.</strong></p>
<p>Das ist der Grund, warum viele Linux-User lieber einen Texteditor, Textdateien und die Kommandozeile mit ihren Befehlen verwenden als eine Textverarbeitung. <strong>Ein Problem muss nur einmal gelöst werden. Die Lösung kann immer wieder auf ähnliche Probleme angewandt werden.</strong></p>
<p>Abbildung 1 veranschaulicht die Befehlszeile:</p>
<div class="figure">
<img src="graphic.png" alt="Die Befehlszeile veranschaulicht" />
<p class="caption">Die Befehlszeile veranschaulicht</p>
</div>
<h1 id="und-jetzt">Und jetzt?</h1>
<p>Wir haben gesehen, dass sich ein alltägliches Problem mithilfe von Textdateien, einfachen Befehlen (<code>wc</code> und <code>sort</code>) und Textströmen effizienter lösen lässt als mit einer Textverarbeitung.</p>
<p>Wer noch weitere solche Techniken kennenlernen möchte, dem empfehle ich den Vortrag <a href="https://www.youtube.com/watch?v=7uwW20odwEk"><em>Power Use of UNIX</em></a> von Dan North.</p>
</body>
</html>
